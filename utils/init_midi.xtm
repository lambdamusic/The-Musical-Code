;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MIDI Play Functions 
; adapted from extempore `mplay` implementation 
;
; Main changes:
;; 1) symbol *mididevice* is implicit and needs to be predefined
;; 2) channel is 0-based in xtm, but here it's 1-based
;
; NOTE: you can always work with more than one midiout instrument
;; simply add a (let ((*mididevice* instrument)) statement so to have local scoping of that variable
;
;
;; author: @lambdamusic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;; PLAY 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; overrides standard play with a midi version + implicit *mididevice*
;
; Args:
; - offset [default = 0]
; - pitch
; - velocity/vol
; - dur 
; - channel (1-based)
;
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (play c3 90 1/2 1)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (play . args)
                (if (length-equal? args 4) 
                    ; 4 args, no offset
                    `(play-midi-note (*metro* beat) 
                                    *mididevice*
                                    (real->integer ,(car args)) ;; pitch
                                    (real->integer ,(cadr args)) ;; vol
                                    (*metro* 'dur ,(car (cddr args))) ;; dur
                                    ;; channel // 0based in xtm, but here it is 1-based
                                    (- (real->integer ,(car (cdddr args))) 1)
                                    )
                    ; 5 args, then we have an offset
                    `(play-midi-note (*metro* (+ beat ,(car args)))         
                                    *mididevice*
                                    (real->integer ,(cadr args))
                                    (real->integer ,(car (cddr args)))
                                    (*metro* 'dur ,(cadr (cddr args)))
                                    (- (real->integer ,(cadr (cdddr args))) 1))))
    )




;; KIT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; play version with defaults: 
; dur = 1/16 , midi = 9  -- eg for drum kits 
;
; Args:
; - offset [default = 0]
; - pitch
; - velocity/ vol
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (kit 60 90)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (kit . args)
                (if (length-equal? args 2) 
                    ; no offset
                    `(play-midi-note (*metro* beat) 
                                    *mididevice*
                                    (real->integer ,(car args))
                                    (real->integer ,(cadr args))
                                    (*metro* 'dur 1/16) ;; dur 1/8
                                    8) ;; midi always 8 == 9 in LIVE
                    ; 3 args, = it's an offset
                    `(play-midi-note (*metro* (+ beat ,(car args)))                *mididevice*
                                    (real->integer ,(cadr args))
                                    (real->integer ,(car (cddr args)))
                                    (*metro* 'dur 1/16)
                                    8)))
)







;; PLAYCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (playchord plist vol-or-vol-list len ch)
; ++ Uses default *mididevice* symbol 
;
; Args:
; - plist 
; - vol-or-vol-list (if single vol, it's duplicated for all notes)
; - dur
; - ch midi
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (playchord '(60 64 67) 60 4 1)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (playchord plist vol len ch)
        `(if (list? ,vol)
            ; list of volumes: ensure it's the right length
            (let ((volumes (cl:expand-list ,vol (- (length ,plist) (length ,vol)))))
                (for-each (lambda (p v)
                            (play-midi-note (*metro* beat) *mididevice*
                                            p
                                            v
                                            (*metro* 'dur ,len)
                                            ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                            (- ,ch 1)
                                            ))
                            ,plist volumes)
                        )
            ; single volume
            (for-each (lambda (p)
                        (play-midi-note (*metro* beat) *mididevice*
                                        p
                                        ,vol
                                        (*metro* 'dur ,len)
                                        ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                        (- ,ch 1)
                                        ))
                        ,plist))
                ))






;; MU:TEST and MU:TESTCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple functions usable for *testing* sounds/instruments
;; both with/without time abstractions
;; Variable num of args
;; MIDI channel is 1-based
;; IMPORTANT need *mididevice*  to be predefined 
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (mu:test 38) ; MIDI channel defaults to 1
; (mu:testchord '(60 63 67) )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;


(impc:aot:do-or-emit
   (define-macro (mu:test . args)
      (cond ((length-equal? args 1) ;; just note
            `(play-midi-note (now) *mididevice* ,(car args) 80 *second* 0))
            ((length-equal? args 2) ; note and midi ch
            `(play-midi-note (now) *mididevice* ,(car args)  80 *second* (- ,(cadr args) 1)))
            ((length-equal? args 3) ;; also mididevice
            `(play-midi-note (now) ,(car args) ,(cadr args)  80 *second* (- ,(caddr args) 1))) 
            (#t (print 'Error: '1 'or '3 'args' 'max))))
)


(impc:aot:do-or-emit
   (define-macro (mu:testchord . args)
      (cond ((length-equal? args 1) ;; just notes list
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* 0))
                        ,(car args)))
            ((length-equal? args 2) ;; note + channel 1-based
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* (- ,(cadr args) 1)))
                        ,(car args)))
            (#t (print 'Error: '1 'or '2 'args' 'max))))

)





;; MIDI CONTROL CHANGE  
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; midi control change with implicit beat & *mididevice*
; (:mcc cc|40 val|90 {ch|0})  # channel is optional
; ++ Uses default *mididevice* symbol 
;
; Args:
; - control change 
; - value
; - ch midi [optional - default is 0]
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (:mcc 49 127) 
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;



; prerequisite 
; see https://github.com/digego/extempore/blob/master/libs/external/portmidi.xtm#L877
; (not loaded with xtm by default)
 
(impc:aot:do-or-emit
 (define send-midi-cc
   (lambda (time device cc val channel)
     (callback time 'pm_send device *midi-cc* channel (real->integer cc) (real->integer val)))))



(impc:aot:do-or-emit
    (define-macro (:mcc . args)
                (if (length-equal? args 2) 
                    ; 2 args = no channel, default=0  ==> good for Ableton LIVE
                    `(send-midi-cc (*metro* beat) 
                        *mididevice*
                        (real->integer ,(car args))    ;; control change
                        (real->integer ,(cadr args))   ;; value
                        0
                        )
                
                    ; 3 args = then we have a channel number 0-based
                    `(send-midi-cc (*metro* beat)  
                        *mididevice*
                        (real->integer ,(car args))            ;; control change
                        (real->integer ,(cadr args))           ;; value
                        (real->integer ,(caddr args))     ;; channel 
                        )))
    )




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tips about with :mcc in Ableton Live 
;
; -- channel is 0 by default
; -- value go from 0 to 127 
; -- program change has some defaults 
;
;; https://forum.ableton.com/viewtopic.php?t=140489
;; => ~/Library/Preferences/Ableton/Live 9.2.3/User Remote Scripts/extempore/UserConfiguration.txt
;
;; https://help.ableton.com/hc/en-us/articles/360010389480-Using-MIDI-CC-in-Live
;
;; RUNDOWN
;; some basic cc mappings have defaults, 1 to 26 (see below)
;;;; eg volume and send effect knobs can be stored in settings file
;
; VolumeSlider1: 1
; VolumeSlider2: 2
; VolumeSlider3: 3
; VolumeSlider4: 4
; VolumeSlider5: 5
; VolumeSlider6: 6
; VolumeSlider7: 7
; VolumeSlider8: 8
;;
; Send1Knob1: 11
; Send1Knob2: 12
; Send1Knob3: 13
; Send1Knob4: 14
; Send1Knob5: 15
; Send1Knob6: 16
; Send1Knob7: 17
; Send1Knob8: 18
; Send2Knob1: 19
; Send2Knob2: 20
; Send2Knob3: 21
; Send2Knob4: 22
; Send2Knob5: 23
; Send2Knob6: 24
; Send2Knob7: 25
; Send2Knob8: 26
;;
;
;; Other mappings how to:
 ; 1 - turn on midi learn, select a control 
 ; 2 - send signal to store mapping

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 






; RULLATE FOR KITS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Legacy implentation of simple drum progressions. 
;; Dependency: 'kit' function
;
;
; Example
; (let ((beat (*metro* 'get-beat)))
;    (rollup 38 6 1/2))
;
; TODO 
; Allow passing MIDI ch (now relies on `kit` hence default is ch-9 )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define-macro (rollup pitch)
   `(let loop ((i 0))
         (kit (* i 1/10) ,pitch (+ 50 (expt 4 i)))
         (if (< i 3) (loop (+ i 1)))))

(define-macro (rolldown pitch)
   `(let loop ((i 0))
         (kit (* i 1/10) ,pitch (- 110 (expt 4 i)))
         (if (< i 3) (loop (+ i 1)))))

(define-macro (roll pitch hits spacing)
      `(let loop ((i 0))
         (kit (* i ,spacing) ,pitch (+ 60 (expt 2 i)))
         (if (< i (- ,hits 1)) (loop (+ i 1)))))



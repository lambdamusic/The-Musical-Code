;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; MIDI Play Functions 
; adapted from extempore `mplay` implementation 
;
; Main changes:
;; 1) symbol *mididevice* is implicit and needs to be predefined
;; 2) channel is 0-based in xtm, but here it's 1-based
;
; NOTE: you can always work with more than one midiout instrument
;; simply add a (let ((*mididevice* instrument)) statement so to have local scoping of that variable
;
;
;; author: @lambdamusic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Changed the 'play' signature 
;; first argument is always the MIDI channel
;; 
;; To revert back: 
;; (sys:load_my_utils "init_midi_legacy.xtm")
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;    
;    
;    
;; PLAY MIDI
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; overrides standard play with a midi version based on scoped *mididevice* symbol
; first argument is always the MIDI channel (or optional offset)
;
; Args:
; - offset [default = 0]
; - channel (1-based)
; - pitch
; - velocity/vol [default = 90]
; - dur  [default = 1/2]
;
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (define sampler 1)
; (let ((beat (*metro* 'get-beat)))
;     (play sampler c3 90 1/2)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (play . args)
        (cond	((length-equal? args 2)
                ; 2 args: instrument // pitch [defaults: vol:90, dur:1/2]
              `(play-midi-note (*metro* beat) 
                              *mididevice*
                              (real->integer ,(cadr args)) ;; pitch
                              90 ;; vol
                              (*metro* 'dur 1/2) ;; dur
                              ;; channel // 0based in xtm, but here it is 1-based
                              (- (real->integer ,(car args)) 1)
                              ))   
              ((length-equal? args 3)
                ; 3 args: instrument // pitch // vol [defaults: dur:1/2]
              `(play-midi-note (*metro* beat) 
                              *mididevice*
                              (real->integer ,(cadr args)) ;; pitch
                              (real->integer ,(caddr args)) ;; vol
                              (*metro* 'dur 1/2) ;; dur
                              ;; channel // 0based in xtm, but here it is 1-based
                              (- (real->integer ,(car args)) 1)
                              ))  
              ((length-equal? args 4) 
                ; 4 args: instrument // pitch // vol // dur 
              `(play-midi-note (*metro* beat) 
                              *mididevice*
                              (real->integer ,(cadr args)) ;; pitch
                              (real->integer ,(caddr args)) ;; vol
                              (*metro* 'dur ,(cadddr args)) ;; dur
                              ;; channel // 0based in xtm, but here it is 1-based
                              (- (real->integer ,(car args)) 1)
                              ))                                
              ((length-equal? args 5) ; [defaults: 90, 1/2, 1]
                ; 4 args: *offset* // instrument // pitch // vol // dur
              `(play-midi-note (*metro* (+ beat ,(car args)))         
                              *mididevice*
                              (real->integer ,(caddr args))
                              (real->integer ,(cadddr args))
                              (*metro* 'dur ,(cadr (cdddr args)))
                              (- (real->integer ,(cadr  args)) 1)
                            ))

              (else (println 'Too 'many 'arguments)) 
        )))




;
;
;; KIT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI Play with defaults: dur = 1/16 , midi = 9  -- eg for drum kits 
;
; Args:
; - offset [default = 0]
; - pitch
; - velocity/ vol
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (kit 60 90)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (kit . args)
                (if (length-equal? args 2) 
                    ; no offset
                    `(play-midi-note (*metro* beat) 
                                    *mididevice*
                                    (real->integer ,(car args))
                                    (real->integer ,(cadr args))
                                    (*metro* 'dur 1/16) ;; dur 1/8
                                    8) ;; midi always 8 == 9 in LIVE
                    ; 3 args, = it's an offset
                    `(play-midi-note (*metro* (+ beat ,(car args)))                
                                    *mididevice*
                                    (real->integer ,(cadr args))
                                    (real->integer ,(car (cddr args)))
                                    (*metro* 'dur 1/16)
                                    8)))
)





;
;
;; SAMPLE
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Play MIDI for Ableton Live Drumkits 
; Goal is to make it easier to access kits as normally organized in Live, using 1-16 numbers 
; Defaults to channel 9
; Pitch start at 36 (ie 1 == 36, 2 == 37) 
; Kit samples go left to right, bottom to top
; eg 36 . . 39 (1st row), 40 . . 43 (2nd row)
;
;
; Args:
; - offset [default = 0]
; - pitch
; - velocity/ vol
; - dur in beats
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (let ((beat (*metro* 'get-beat)))
;     (sample 1 90 1/2)     ;; no offset
;     (sample 1/2 1 90 1/2) ;; offset 1/2
;     (sample 1/2 1 90 1/2 3) ;; override midi channel => 3
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (sample . args)
        (cond 
             ((length-equal? args 1)
                ; 1 arg: pitch
                `(play-midi-note 
                                (*metro* beat) 
                                *mididevice*  ;; constant
                                (+ 35 (real->integer ,(car args)))  ;; pitch
                                90  ;; vol
                                (*metro* 'dur 1/2) ;; dur default
                                8)) ;; midi always 8 == 9 in LIVE  
              ((length-equal? args 2)
                ; 2 args: pitch, vol
                `(play-midi-note 
                                (*metro* beat) 
                                *mididevice*  ;; constant
                                (+ 35 (real->integer ,(car args)))  ;; pitch
                                (real->integer ,(cadr args))  ;; vol
                                (*metro* 'dur 1/2) ;; dur default
                                8)) ;; midi always 8 == 9 in LIVE   
              ((length-equal? args 3)
                ; 3 args => pitch, vol, dur
                `(play-midi-note 
                                (*metro* beat) 
                                *mididevice*  ;; constant
                                (+ 35 (real->integer ,(car args)))  ;; pitch
                                (real->integer ,(cadr args))  ;; vol
                                (*metro* 'dur ,(caddr args)) ;; dur / requires beat defined
                                8)) ;; midi always 8 == 9 in LIVE 
              ((length-equal? args 4) 
                ; 4 args => offset, pitch, vol, dur
                `(play-midi-note (*metro* (+ beat ,(car args)))                
                                *mididevice*
                                (+ 35 (real->integer ,(cadr args)))  ;; pitch
                                (real->integer ,(caddr args))  ;; vol
                                (*metro* 'dur ,(cadddr args)) ;; dur / requires beat defined
                                8))                               
              ((length-equal? args 5) 
                ; 5 args => offset, pitch, vol, dur, midi channel
                `(play-midi-note (*metro* (+ beat ,(car args)))                
                                *mididevice*
                                (+ 35 (real->integer ,(cadr args)))  ;; pitch
                                (real->integer ,(caddr args))  ;; vol
                                (*metro* 'dur ,(cadddr args)) ;; dur / requires beat defined
                                (- (real->integer ,(caddddr args)) 1))) ;; ch, 0-based in xtm

              (else (println 'Too 'many 'arguments)) 
        ))
)







;
;
;; PLAYCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (playchord plist vol-or-vol-list len ch)
; ++ Uses default *mididevice* symbol 
;
; Args:
; - ch midi
; - plist 
; - vol-or-vol-list (if single vol, it's duplicated for all notes)
; - dur
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (define piano 1)
; (let ((beat (*metro* 'get-beat)))
;     (playchord piano '(60 64 67) 60 4)
;     ))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (playchord ch plist vol len)
        `(if (list? ,vol)
            ; list of volumes: ensure it's the right length
            (let ((volumes (cl:expand-list ,vol (- (length ,plist) (length ,vol)))))
                (for-each (lambda (p v)
                            (play-midi-note (*metro* beat) *mididevice*
                                            p
                                            v
                                            (*metro* 'dur ,len)
                                            ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                            (- ,ch 1)
                                            ))
                            ,plist volumes)
                        )
            ; single volume
            (for-each (lambda (p)
                        (play-midi-note (*metro* beat) *mididevice*
                                        p
                                        ,vol
                                        (*metro* 'dur ,len)
                                        ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                        (- ,ch 1)
                                        ))
                        ,plist))
                ))









;
;
;; inner function for :arp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; eg 
; (helper:arpeggio (*metro* 'get-beat) 0 
;   '(c4 f4 g4 c5) 3 90 3) ;; durs/vols do not need to be a list
; (helper:arpeggio (*metro* 'get-beat) 0
;   '(c4 f4 g4 c5) '(3) '(90) 3) ;; a list works too
(define helper:arpeggio
  (lambda (beat offset notes durations volumes ch)
    (let* ((durs (cl:expand-list2 durations (len notes)))
          (vols (cl:expand-list2 volumes (len notes)))
          (total_dur (sum_list durs))
          (wait (car durs)))
      (when #f (println notes durs))
      (play (eval offset) ch (eval (car notes)) (car vols) total_dur )
      (if (not (null? (cdr notes)))
        (callback (*metro* (+ beat (* 1/2 wait))) 
          'helper:arpeggio (+ beat wait) offset
          (rest notes) (rest durs) (rest vols) ch))))) 




;
;
; :ARP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Play notes in sequence by adding them on top of each other, like an arpeggio.
; The total time is given by the sum of all durations.
; Notes keep playing over each other till the last note completes its duration.
;
;
; Args:
; ----
; offset (opt)
; channel 
; notes
; durs 
; vols 
; 
; durst & vols: if an atom is passed, it's 'expanded' into a list (= same for all notes)
; (durs => the dur of each note, before the following one kicks in)
; 
; 
; Requires:
; --------
; beat 
; *mididevice*
;
; 
; Example:
; --------
; (define piano 1) ;; midi ch
; (let ((beat (*metro* 'get-beat)))
;   (arp piano '(60 67) 4 90) 
;   (arp 2 piano '(60 67) 4 90)  ;; 2 = offset
;   (arp piano (:mkchord c4 '^ 4) (:mklist 4 (oneof 1 2 3)) 90)
; )
;
;
; Dependencies:
; -------------------------------
; * helper:arpeggio
; * play (midi version)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
(impc:aot:do-or-emit
  (define-macro (:arp . args)
    ; (println (car args) (len args))
    (cond ((length-equal? args 4)
        ;; 4 args: ch // plist // tlist // vols
        ;; ==> memo: helper:arpeggio takes: beat offset notes durations volumes ch
          `(begin (println ,@args) (helper:arpeggio beat 0 ,(cadr args) ,(caddr args) ,(cadddr args) ,(car args) )))
           ((length-equal? args 5)
        ;; 5 args: offset // ch // plist // tlist // vols
          `(helper:arpeggio beat ,(car args) ,(caddr args) ,(cadddr args) ,(caddddr args) ,(cadr args) )) 
          (else (log-error 'arp: 'arguments 'could 'not 'be 'resolved.))))) 




;
;
;; MU:TEST and MU:TESTCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple functions usable for *testing* sounds/instruments
;; both with/without time abstractions
;; Variable num of args
;; MIDI channel is 1-based
;; IMPORTANT need *mididevice*  to be predefined 
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (mu:test 38) ; MIDI channel defaults to 1
; (mu:testchord '(60 63 67) )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
   (define-macro (mu:test . args)
      (cond ((length-equal? args 1) ;; just note
            `(play-midi-note (now) *mididevice* ,(car args) 80 *second* 0))
            ((length-equal? args 2) ; note and midi ch
            `(play-midi-note (now) *mididevice* ,(car args)  80 *second* (- ,(cadr args) 1)))
            ((length-equal? args 3) ;; also mididevice
            `(play-midi-note (now) ,(car args) ,(cadr args)  80 *second* (- ,(caddr args) 1))) 
            (#t (print 'Error: '1 'or '3 'args' 'max))))
)





;
;
;; MU:TEST and MU:TESTCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple functions usable for *testing* sounds/instruments
;; both with/without time abstractions
;; Variable num of args
;; MIDI channel is 1-based
;; IMPORTANT need *mididevice*  to be predefined 
;
; Example:
; (define *mididevice* (pm_create_output_stream 1))
; (mu:test 38) ; MIDI channel defaults to 1
; (mu:testchord '(60 63 67) )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
   (define-macro (mu:testchord . args)
      (cond ((length-equal? args 1) ;; just notes list
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* 0))
                        ,(car args)))
            ((length-equal? args 2) ;; note + channel 1-based
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* (- ,(cadr args) 1)))
                        ,(car args)))
            (#t (print 'Error: '1 'or '2 'args' 'max))))

)





;
;
; rollup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Legacy implentation of simple drum progressions. 
;; Dependency: 'kit' function
;
;
; Example
; (let ((beat (*metro* 'get-beat)))
;    (rollup 38 ))
;
; TODO 
; Allow passing MIDI ch (now relies on `kit` hence default is ch-9 )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-macro (rollup pitch)
   `(let loop ((i 0))
         (play 9 (* i 1/10) ,pitch (+ 50 (expt 4 i)))
         (if (< i 3) (loop (+ i 1)))))


;
;
; rolldown
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Legacy implentation of simple drum progressions. 
;; Dependency: 'kit' function
;
;
; Example
; (let ((beat (*metro* 'get-beat)))
;    (rolldown 38 ))
;
; TODO 
; Allow passing MIDI ch (now relies on `kit` hence default is ch-9 )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-macro (rolldown pitch)
   `(let loop ((i 0))
         (play 9 (* i 1/10) ,pitch (- 110 (expt 4 i)))
         (if (< i 3) (loop (+ i 1)))))


;
;
; roll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Legacy implentation of simple drum progressions. 
;; Dependency: 'kit' function
;
;
; Example
; (let ((beat (*metro* 'get-beat)))
;    (roll 38 6 1/2))
;
; TODO 
; Allow passing MIDI ch (now relies on `kit` hence default is ch-9 )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-macro (roll pitch hits spacing)
      `(let loop ((i 0))
         (play 9 (* i ,spacing) ,pitch (+ 60 (expt 2 i)))
         (if (< i (- ,hits 1)) (loop (+ i 1)))))







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  MIDI CONTROL CHANGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




 
(define *mcc-verbose* #f)

;; channel used to send CC messages
; PS default channel is 0 / ensure there is no conflict with Ableton mixer function that are 
; on a different channel *ableton-default-cc-channel*
(define *mcc-default-channel* 0)



;
; midi control change
;  see https://github.com/digego/extempore/blob/master/libs/external/portmidi.xtm#L877
; (not loaded with xtm by default)
(impc:aot:do-or-emit
 (define send-midi-cc
   (lambda (time device cc val channel)
     (if *mcc-verbose* (println 'mcc cc val))
     (callback time 'pm_send device *midi-cc* channel (real->integer cc) (real->integer val)))))



;
;; :mcc MIDI CONTROL CHANGE SHORTCUT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ++ Uses default *mididevice* symbol 
;; Values are set in real-time using now() // [not beat]
;;
;; Args:
; - control change 
; - value
; - ch midi [optional - default is *mcc-default-channel*]
;
;; Example:
; (mcc 49 127) 
; 
;
;; In order to set up mappings in Live:
 ; 1 - turn on midi learn in Live, select a control 
 ; 2 - send :mcc signal to store mapping
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (:mcc . args)
                (if (length-equal? args 2) 
                    ; 2 args = no channel default=0  ==> good for Ableton LIVE
                    `(send-midi-cc (now) ;;(*metro* beat) 
                        *mididevice*
                        (real->integer ,(car args))    ;; control change
                        (real->integer ,(cadr args))   ;; value
                        *mcc-default-channel* ;; channel
                        )
                    ; 3 args = then we have a channel number 0-based
                    `(send-midi-cc (now) ;;(*metro* beat)  
                        *mididevice*
                        (real->integer ,(car args))            ;; control change
                        (real->integer ,(cadr args))           ;; value
                        (real->integer ,(caddr args))     ;; channel 
                        )))
    )







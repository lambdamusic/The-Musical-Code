;;;;
;;
;
; Player function for MIDI, with implicit midi device *mididevice*
;
;
; ==Requirements==
;
; * REQUIRES *mididevice* MAPPED TO AN OUTPUT STREAM
; * CHANNEL: ch is 0based in xtm, but the function accepts it as 1-based
;;  this gives more alignment with AU HOSTS eg Ableton
; * NOTE: you can always work with more than one midiout instrument
;; simply add a (*mididevice* instrument) statement to your let to have local scoping of that variable
;
;
;;;



;; PLAY 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; overrides standard play with a midi version

; Args:
; - offset [default = 0]
; - pitch
; - velocity/ vol
; - dur 
; - channel (1-based)
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (play . args)
                (if (length-equal? args 4) ; no offset
                    `(play-midi-note (*metro* beat) *mididevice*
                                    (real->integer ,(car args)) ;; pitch
                                    (real->integer ,(cadr args)) ;; vol
                                    (*metro* 'dur ,(car (cddr args))) ;; dur
                                    ;; channel // 0based in xtm, but user sends it as 1-based
                                    (- (real->integer ,(car (cdddr args))) 1)
                                    )
                    ; if 5, then it's an offset
                    `(play-midi-note (*metro* (+ beat ,(car args))) *mididevice*
                                    (real->integer ,(cadr args))
                                    (real->integer ,(car (cddr args)))
                                    (*metro* 'dur ,(cadr (cddr args)))
                                    (- (real->integer ,(cadr (cdddr args))) 1))))
    )



;;; test
; (pm_print_devices)
; (define *mididevice* (pm_create_output_stream 3))
(if #f
    (let ((beat (*metro* 'get-beat)))
        (play 1/2 60 90 1 1)
        ))




;; KIT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; play version with defaults: dur = 1/16 , midi = 9  -- eg for drum kits 
; (kit 36 90) # dur = 1/16 , midi = 9 (0 in extempore)
;
; Args:
; - offset [default = 0]
; - pitch
; - velocity/ vol
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (kit . args)
                (if (length-equal? args 2) ; no offset
                    `(play-midi-note (*metro* beat) *mididevice*
                                    (real->integer ,(car args))
                                    (real->integer ,(cadr args))
                                    (*metro* 'dur 1/16) ;; dur 1/8
                                    8) ;; midi always 8 == 9 in LIVE
                    ; if 4, then it's an offset
                    `(play-midi-note (*metro* (+ beat ,(car args))) *mididevice*
                                    (real->integer ,(cadr args))
                                    (real->integer ,(car (cddr args)))
                                    (*metro* 'dur 1/16)
                                    8)))
)







;; PLAYCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (playchord plist vol-or-vol-list len ch)
; ++ Uses default *mididevice* symbol 
;
; Args:
; - plist 
; - vol-or-vol-list (if single vol, it's duplicated for all notes)
; - dur
; - ch midi
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (playchord plist vol len ch)
        `(if (list? ,vol)
            (let ((volumes (cl:expand-list ,vol (- (length ,plist) (length ,vol)))))
                (for-each (lambda (p v)
                            (play-midi-note (*metro* beat) *mididevice*
                                            p
                                            v
                                            (*metro* 'dur ,len)
                                            ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                            (- ,ch 1)
                                            ))
                            ,plist volumes)
                        )
            (for-each (lambda (p)
                        (play-midi-note (*metro* beat) *mididevice*
                                        p
                                        ,vol
                                        (*metro* 'dur ,len)
                                        ;; NOTE ch is 0based in xtm, but user sends it as 1-based
                                        (- ,ch 1)
                                        ))
                        ,plist))
                ))






;; MU:TEST and MU:TESTCHORD 
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple functions usable for *testing* sounds/instruments
;; both with/without time abstractions
;; Variable num of args
;; MIDI channel is 1-based (as in Ableton Live)
;; IMPORTANT need *mididevice*  to be predefined 
;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; MIDI versions
(impc:aot:do-or-emit
   (define-macro (mu:test . args)
      (cond ((length-equal? args 1) ;; just note
            `(play-midi-note (now) *mididevice* ,(car args) 80 *second* 0))
            ((length-equal? args 2) ; note and midi ch
            `(play-midi-note (now) *mididevice* ,(car args)  80 *second* (- ,(cadr args) 1)))
            ((length-equal? args 3) ;; also mididevice
            `(play-midi-note (now) ,(car args) ,(cadr args)  80 *second* (- ,(caddr args) 1))) 
            (#t (print 'Error: '1 'or '3 'args' 'max))))
)


(impc:aot:do-or-emit
   (define-macro (mu:testchord . args)
      (cond ((length-equal? args 1) ;; just notes list
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* 0))
                        ,(car args)))
            ((length-equal? args 2) ;; note + channel 1-based
            `(for-each (lambda (x)
                        (play-midi-note (now) *mididevice* x 80 *second* (- ,(cadr args) 1)))
                        ,(car args)))
            (#t (print 'Error: '1 'or '2 'args' 'max))))

)




;; :MCC
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; midi control change with implicit beat & *mididevice*
;; (:mcc cc|40 val|90 ch|1)
;
; Can also take an offset [default = 0]
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; PREREQUISITE
; see https://github.com/digego/extempore/blob/master/libs/external/portmidi.xtm#L877
;; for some reason these snippets are not loaded by default 
(impc:aot:do-or-emit
 (define send-midi-cc
   (lambda (time device cc val channel)
     (callback time 'pm_send device *midi-cc* channel (real->integer cc) (real->integer val)))))



(impc:aot:do-or-emit
    (define-macro (:mcc . args)
                (if (length-equal? args 3) ; no offset
                    `(send-midi-cc (*metro* beat) 
                        *mididevice*
                        (real->integer ,(car args))    ;; control change
                        (real->integer ,(cadr args))   ;; value
                        (real->integer ,(caddr args))  ;; channel / 1-based
                        )
                
                    ; if 4, then it's an offset
                    `(send-midi-cc (*metro* (+ beat ,(car args)))   ;; offset
                        *mididevice*
                        (real->integer ,(cadr args))            ;; control change
                        (real->integer ,(caddr args))           ;; value
                        (real->integer ,(car (cdddr args)))     ;; channel / 1-based
                        )))
    )


;; :MCCLIVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Ableton LIVE relies on user-defined config, which defaults to channel 0
;; (:mcclive cc|40 val|90 )
;;
;; see current mappings in
;; ~/Library/Preferences/Ableton/Live 9.2.3/User Remote Scripts/extempore/UserConfiguration.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(impc:aot:do-or-emit
    (define-macro (:mcclive . args)
        `(send-midi-cc (*metro* beat) 
            *mididevice*
            (real->integer ,(car args))    ;; control change
            (real->integer ,(cadr args))   ;; value
            0  ;; channel / 0 by default based on user-defined LIVE settings
            )))










; =====================
; =====================
; =====================
;
; 2. CONDITIONAL STATEMENTS TO WORK WITH METRO BEATS
;
; =====================
; =====================
; =====================



;;--------
;
;  <:BAR and :BEAT -procedures->
;
;; WORKING EXAMPLE
; (let ((beat (*metro* 'get-beat)))
;   (:bar 8
;     (:beat '(0 4) (play c3 90 1 1))
;     (:beat '(0 1 5) (play g3 90 1 1))
;     (:beat '(2 6) (play a3 90 1 1))
;     (:beat '(3 7) (play f3 90 1 1))
;     )
; )
;
;;;--------


; (define-macro (:bar args)
; `(let ((*denom* ,(cadr args)))
;     ,@(cddr args)))



; (define-macro (:beat y . args)
; `(for-each (lambda (step)
;                 (if (equal? (modulo beat *denom*) step)
;                     (begin ,@args)))
;             (if (list? ,y)
;                 ,y
;                 (list ,y))))




(impc:aot:do-or-emit
    (define-macro (:bar . args)
    `(let ((*denom* ,(car args)))
        ,@(cdr args)))
)

(impc:aot:do-or-emit
    (define-macro (:beat y . args)
    `(for-each (lambda (step)
                    (if (equal? (modulo beat *denom*) step)
                        (begin ,@args)))
                (if (list? ,y)
                    ,y
                    (list ,y))))
)





;;--------
;
;  <ONBEAT X Y -procedures->
;
; X = the DENOMINATOR 
; Y = the NUMERATOR (0 BASED)
; Y Accepts both single numbers and lists
;
;; (let ((beat (*metro* 'get-beat)))
;;   (onbeat 2 0 (play dls 60 60 1))
;;   (onbeat 4 '(0 2 3/2) (play dls 48 60 1)))
;
;;;--------


(impc:aot:do-or-emit
    (define-macro (onbeat x y . args)
    `(for-each (lambda (step)
                    (if (equal? (modulo beat ,x) step)
                        (begin ,@args)))
                (if (list? ,y)
                    ,y
                    (list ,y))))
)



;;--------
;
;  <IFBEAT>
;
; <IFBEAT X Y -PROCEDURE- ELSE -PROCEDURE2->
;
;  Y: Accepts both single numbers and lists
;
;
;;;--------


(impc:aot:do-or-emit
    (define-macro (ifbeat x y args . elseargs)
    `(for-each (lambda (step)
                    (if (equal? (modulo beat ,x) ,y)
                        ,args
                        ,@elseargs))
                (if (list? ,y)
                    ,y
                    (list ,y))))
)



;;--------
;
;  <IFBEAT-GT>
;
;;;--------

(impc:aot:do-or-emit
    (define-macro (ifbeat-gt x y args . elseargs)
    `(if (> (modulo beat ,x) ,y)
            ,args
            ,@elseargs))
)



;;--------
;
;  <IFBEAT-LT>
;
;;;--------


;; same as (let ((n (if (< (modulo beat 8) 4) 0 2))) 

(impc:aot:do-or-emit
    (define-macro (ifbeat-lt x y args . elseargs)
    `(if (< (modulo beat ,x) ,y)
            ,args
            ,@elseargs))
)




;;--------
;
;  <IFBEAT-BTW X Y Z procedure &elseprocedure>
;
;
;;;--------

(impc:aot:do-or-emit
    (define-macro (ifbeat-btw x y z args . elseargs)
    `(if (and (> (modulo beat ,x) ,y) (< (modulo beat ,x) ,z))
            ,args
            ,@elseargs))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Utilities for *metro* beat constructs 
;
;
;; author: @lambdamusic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





;
;
; :BAR and :BEAT macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;; EXAMPLE
; (let ((beat (*metro* 'get-beat)))
;   (:bar 8
;     (:beat '(0 4) (play c3 90 1 1))
;     (:beat '(0 1 5) (play g3 90 1 1))
;     (:beat '(2 6) (play a3 90 1 1))
;     (:beat '(3 7) (play f3 90 1 1))
;     )
; )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (:bar . args)
    `(let ((*denom* ,(car args)))
        ,@(cdr args)))
)

;
;
; :BAR and :BEAT macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;; EXAMPLE
; (let ((beat (*metro* 'get-beat)))
;   (:bar 8
;     (:beat '(0 4) (play c3 90 1 1))
;     (:beat '(0 1 5) (play g3 90 1 1))
;     (:beat '(2 6) (play a3 90 1 1))
;     (:beat '(3 7) (play f3 90 1 1))
;     )
; )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (:beat y . args)
    `(for-each (lambda (step)
                    (if (equal? (modulo beat *denom*) step)
                        (begin ,@args)))
                (if (list? ,y)
                    ,y
                    (list ,y))))
)




;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; UTILITY TO ALLOW PASSING NEGATIVE VALUES TO ONBEAT FUNCTIONS
; (helper:handle_negatives_beats 4 -1/4) => 15/4
; (helper:handle_negatives_beats 4 -1/2) => 7/2
; (helper:handle_negatives_beats 4 -5) => -1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define helper:handle_negatives_beats
  (lambda (x y)
    (if (< y 0)
      (+ x y)
      y)
    ))


;
;
;; ONBEAT X Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (onbeat denominator (list of numerators) (do ...... )) 
;
; Args:
; X = the DENOMINATOR 
; Y = the NUMERATOR (0 BASED)
; Y Accepts both single numbers and lists
;
; Note
; Pass '0' as denominator to bypass execution (ie to mute while playing)

; Example:
;; (let ((beat (*metro* 'get-beat)))
;;   (onbeat 2 0 (play dls 60 60 1))
;;   (onbeat 4 '(0 2 3/2) (play dls 48 60 1)))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (onbeat x y . args)
    `(if (> ,x 0)
      (for-each (lambda (step)
                      (if (equal? (modulo beat ,x) (helper:handle_negatives_beats ,x step))
                          (begin ,@args)))
                  (if (list? ,y)
                      ,y
                      (list ,y))))
    )
)



;; June 18, 2021
;
;
; at / alias for onbeat
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (at denominator (list of numerators) (do ...... )) 
;
; Args:
; X = the DENOMINATOR 
; Y = the NUMERATOR (0 BASED)
; Y Accepts both single numbers and lists
;
; Note
; Pass '0' as denominator to bypass execution (ie to mute while playing)

; Example:
;; (let ((beat (*metro* 'get-beat)))
;;   (at 2 0 (play dls 60 60 1))
;;   (at 4 '(0 2 3/2) (play dls 48 60 1)))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define at onbeat)


;;
;; atbtw
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; same as at, but with range
;; Note: this is like when-btw
;;
;; example
;
; (let ((beat (*metro* 'get-beat 1))) 
;     (atbtw 4 0 4
;         (log-info beat)
;         (log-info 'hi)
; ))  
;
(impc:aot:do-or-emit
    (define-macro (atbtw x y z . args)
    `(if (and (> (modulo beat ,x) ,y) (< (modulo beat ,x) ,z)) 
            (begin ,@args)))
)  





;
;
;; IFBEAT X Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (ifbeat denominator numerator (do ...) (else do ....))
;
;
;  Y: Accepts both single numbers and lists
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (ifbeat x y args . elseargs)
    `(if (> ,x 0)
     (for-each (lambda (step)
                    (if (equal? (modulo beat ,x) (helper:handle_negatives_beats ,x step))
                        ,args
                        ,@elseargs))
                (if (list? ,y)
                    ,y
                    (list ,y))))
    )
)



;
;
;; IFBEAT-GT X Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; if beat greater than X
;
; (ifbeat-gt denominator numerator (do ...) (else do ....))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (ifbeat-gt x y args . elseargs)
    `(if (> (modulo beat ,x) ,y)
            ,args
            ,@elseargs))
)



;
;
;; IFBEAT-LT X Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; if beat less than X
;
; (ifbeat-lt denominator numerator (do ...) (else do ....))
;
; same as (let ((n (if (< (modulo beat 8) 4) 0 2))) 
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (ifbeat-lt x y args . elseargs)
    `(if (< (modulo beat ,x) ,y)
            ,args
            ,@elseargs))
)



;
;
;; IFBEAT-BTW X Y Z
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; if beat between X and Y 
;
; (ifbeat-btw denominator numerator-left numerator-right (do ...) (else do ....))
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(impc:aot:do-or-emit
    (define-macro (ifbeat-btw x y z args . elseargs)
    `(if (and (> (modulo beat ,x) ,y) (< (modulo beat ,x) ,z))
            ,args
            ,@elseargs))
)








;
;
;; EVERY N loops, do X, ELSE Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Requires `LC` symbol to be in scope and incremented at each iteration
;
; (let ((LC 4))
;   (every 2 (list 4 5) 'no)
;   )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-macro (every . args)
  ;;(println args)
   `(if (= (modulo LC ,(car args)) 0)
        ,(cadr args)
        ,(caddr args)))


